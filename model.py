import pandas as pd
import numpy as np
import random
import sys
import xlrd
from collections import defaultdict
import pickle
import re
import argparse
import os
import time

# for reading and displaying images
from skimage.io import imread
from pathlib import Path
import matplotlib.pyplot as plt

# for creating validation set
from sklearn.model_selection import train_test_split

# for evaluating the model
from sklearn.metrics import accuracy_score
from tqdm import tqdm

# PyTorch libraries and modules
import torch
from torch import optim
from torch.autograd import Variable
from torch.nn import Linear, ReLU, CrossEntropyLoss, Sequential, Conv2d, MaxPool2d, Module, Softmax, \
    BatchNorm2d, Dropout, Sigmoid, MSELoss, L1Loss
from torch.optim import Adam, SGD, Adadelta
from torch.utils.data import DataLoader, TensorDataset, Dataset, Sampler
from torchvision.transforms import Compose, RandomCrop, RandomResizedCrop, ToPILImage, ToTensor, Lambda,\
    RandomHorizontalFlip, RandomRotation, RandomAffine, RandomPerspective, Grayscale, Normalize, Resize, CenterCrop, Pad, Normalize


import base64
from PIL import Image
from io import BytesIO
# import glow

device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
# device = torch.device("cpu")
size = (1920, 844)
cropped_size = (256, 128)
model_name = 'model'
random.seed(34)
criterion_number = 6
crit = 2

train_f = ('-t' in sys.argv)
cont_f = ('-c' in sys.argv)
files_f = ('-f' in sys.argv)


def read_xl(filename):
    wb = xlrd.open_workbook(filename)
    sheet = wb.sheet_by_index(0)
    i = 7
    lines = []
    while i < sheet.nrows:
        pic = str(int(sheet.cell_value(i, 0))) + '.png'
        marks = []
        for i in range(i+1, i+1+criterion_number):
            mark = int(sheet.cell_value(i, 1))
            marks.append(mark)
        line = (pic, *marks)
        lines.append(line)
        i += 1
    return lines


def create_files(file_path, val):
    lines = []
    lines = read_xl(file_path)
    if val:
        with open('val.pkl', 'wb') as valfile:
            pickle.dump(lines, valfile, protocol=pickle.HIGHEST_PROTOCOL)
            return

    random.shuffle(lines)
    train_size = int(0.8 * len(lines))
    train_xy = lines[:train_size]
    test_xy = lines[train_size:]
    with open('train.pkl', 'wb') as trainfile:
        pickle.dump(train_xy, trainfile, protocol=pickle.HIGHEST_PROTOCOL)
    with open('test.pkl', 'wb') as testfile:
        pickle.dump(test_xy, testfile, protocol=pickle.HIGHEST_PROTOCOL)


def load_last(model_name, model, root='checkpoints'):
    root = Path(root)
    pat = re.compile(r'.*_(?P<epoch>[0-9]+)_(?P<loss>[0-9\.]+).pth')

    matches = (pat.match(p.name) for p in root.glob(f'{model_name}_*.pth'))
    epoch, m = max(((int(m['epoch']), m) for m in matches), key=lambda x: x[0])

    path = root / m.string
    model.load_state_dict(torch.load(path, map_location='cpu'))
    print('Loading: ' + str(path))
    return epoch, float(m['loss'])


def load_dataset(data_file):
    image_paths = []
    scores = []
    with open(data_file, 'rb') as fp:
        XY = pickle.load(fp)
    for line in XY:
        image_paths.append(line[0])
        scores.append(line[1:])
        # scores.append(line[crit])

    Y = np.array(scores, 'float32')
    Y /= 10.0
    return image_paths, Y


class Net(Module):
    def __init__(self, init=64):
        super(Net, self).__init__()

        self.cnn_layers = Sequential(
            # MaxPool2d(kernel_size=2, stride=2),
            BatchNorm2d(1),
            Conv2d(1, init, kernel_size=3, stride=1, padding=1),
            ReLU(inplace=True),
            MaxPool2d(kernel_size=4, stride=4),
            # Dropout(0.1),
            # Defining a 2D convolution layer
            Conv2d(init, init * 2, kernel_size=3, stride=1, padding=1),
            ReLU(inplace=True),
            MaxPool2d(kernel_size=2, stride=2),
            Dropout(0.1),
            # Defining another 2D convolution layer
            Conv2d(init * 2, init * 4, kernel_size=3, stride=1, padding=1),
            ReLU(inplace=True),
            MaxPool2d(kernel_size=2, stride=2),
            # Dropout(0.1),

            Conv2d(init * 4, init * 4, kernel_size=3, stride=1, padding=1),
            ReLU(inplace=True),
            MaxPool2d(kernel_size=2, stride=2),
            Dropout(0.1),
        )
        self.linear_layers = Sequential(
            Linear((cropped_size[0] // 32) * (cropped_size[1] // 32) * init * 4, init * 2),
            ReLU(inplace=True),
            Dropout(0.5),
            Linear(init * 2, 1),
            Sigmoid(),
        )

    # Defining the forward pass
    def forward(self, x):
        x = self.cnn_layers(x)
        x = x.view(x.size(0), -1)
        return self.linear_layers(x)

test_64 = 'iVBORw0KGgoAAAANSUhEUgAABecAAALRCAYAAADRHxj7AAAgAElEQVR4XuzdBbQtS3U27PeDi/uHQwIkOBd3d7jIxeUigSQQgruFBAIEQgiuQb5AgrtrcHd3CxYcQpBAcP4xofefRdNrL9lr1bKnxjgD7t7dNauerrPPObNrzfo/0QgQIECAAAECBAgQIECAAAECBAgQIECAAIGmAv+naTTBCBAgQIAAAQIECBAgQIAAAQIECBAgQIAAgUjOWwQECBAgQIAAAQIECBAgQIAAAQIECBAgQKCxgOR8Y3DhCBAgQIAAAQIECBAgQIAAAQIECBAgQICA5Lw1QIAAAQIECBAgQIAAAQIECBAgQIAAAQIEGgtIzjcGF44AAQIECBAgQIAAAQIECBAgQIAAAQIECEjOWwMECBAgQIAAAQIECBAgQIAAAQIECBAgQKCxgOR8Y3DhCBAgQIAAAQIECBAgQIAAAQIECBAgQICA5Lw1QIAAAQIECBAgQIAAAQIECBAgQIAAAQIEGgtIzjcGF44AAQIECBAgQIAAAQIECBAgQIAAAQIECEjOWwMECBAgQIAAAQIECBAgQIAAAQIECBAgQKCxgOR8Y3DhCBAgQIAAAQIECBAgQIAAAQIECBAgQICA5Lw1QIAAAQIECBAgQIAAAQIECBAgQIAAAQIEGgtIzjcGF44AAQIECBAgQIAAAQIECBAgQIAAAQIECEjOWwMECBAgQIAAAQIECBAgQIAAAQIECBAgQKCxgOR8Y3DhCBAgQIAAAQIECBAgQIAAAQIECBAgQICA5Lw1QIAAAQIECBAgQIAAAQIECBAgQIAAAQIEGgtIzjcGF44AAQIECBAgQIAAAQIECBAgQIAAAQIECEjOWwMECBAgQIAAAQIECBAgQIAAAQIECBAgQKCxgOR8Y3DhCBAgQIAAAQIECBAgQIAAAQIECBAgQICA5Lw1QIAAAQIECBAgQIAAAQIECBAgQIAAAQIEGgtIzjcGF44AAQIECBAgQIAAAQIECBAgQIAAAQIECEjOWwMECBAgQIAAAQIECBAgQIAAAQIECBAgQKCxgOR8Y3DhCBAgQIAAAQIECBAgQIAAAQIECBAgQICA5Lw1QIAAAQIECBAgQIAAAQIECBAgQIAAAQIEGgtIzjcGF44AAQIECBAgQIAAAQIECBAgQIAAAQIECEjOWwMECBAgQIAAAQIECBAgQIAAAQIECBAgQKCxgOR8Y3DhCBAgQIAAAQIECBAgQIAAAQIECBAgQICA5Lw1QIAAAQIECBAgQIAAAQIECBAgQIAAAQIEGgtIzjcGF44AAQIECBAgQIAAAQIECBAgQIAAAQIECEjOWwMECBAgQIAAAQIECBAgQIAAAQIECBAgQKCxgOR8Y3DhCBAgQIAAAQIECBAgQIAAAQIECBAgQICA5Lw1QIAAAQIECBAgQIAAAQIECBAgQIAAAQIEGgtIzjcGF44AAQIECBAgQIAAAQIECBAgQIAAAQIECEjOWwMECBAgQIAAAQIECBAgQIAAAQIECBAgQKCxgOR8Y3DhCBAgQIAAAQIECBAgQIAAAQIECBAgQICA5Lw1QIAAAQIECBAgQIAAAQIECBAgQIAAAQIEGgtIzjcGF44AAQIECBAgQIAAAQIECBAgQIAAAQIECEjOWwMECBAgQIAAAQIECBAgQIAAAQIECBAgQKCxgOR8Y3DhCBAgQIAAAQIECBAgQIAAAQIECBAgQICA5Lw1QIAAAQIECBAgQIAAAQIECBAgQIAAAQIEGgtIzjcGF44AAQIECBAgQIAAAQIECBAgQIAAAQIECEjOWwMECBAgQIAAAQIECBAgQIAAAQIECBAgQKCxgOR8Y3DhCBAgQIAAAQIECBAgQIAAAQIECBAgQICA5Lw1QIAAAQIECBAgQIAAAQIECBAgQIAAAQIEGgtIzjcGF44AAQIECBAgQIAAAQIECBAgQIAAAQIECEjOWwMECBAgQIAAAQIECBAgQIAAAQIECBAgQKCxgOR8Y3DhCBAgQIAAAQIECBAgQIAAAQIECBAgQICA5Lw1QIAAAQIECBAgQIAAAQIECBAgQIAAAQIEGgtIzjcGF44AAQIECBAgQIAAAQIECBAgQIAAAQIECEjOWwMECBAgQIAAAQIECBAgQIAAAQIECBAgQKCxgOR8Y3DhCBAgQIAAAQIECBAgQIAAAQIECBAgQICA5Lw1QIAAAQIECBAgQIAAAQIECBAgQIAAAQIEGgtIzjcGF44AAQIECBAgQIAAAQIECBAgQIAAAQIECEjOWwMECBAgQIAAAQIECBAgQIAAAQIECBAgQKCxgOR8Y3DhCBAgQIAAAQIECBAgQIAAAQIECBAgQICA5Lw1QIAAAQIECBAgQIAAAQIECBAgQIAAAQIEGgtIzjcGF44AAQIECBAgQIAAAQIECBAgQIAAAQIECEjOWwMECBAgQIAAAQIECBAgQIAAAQIECBAgQKCxgOR8Y3DhCBAgQIAAAQIECBAgQIAAAQIECBAgQICA5Lw1QIAAAQIECBAgQIAAAQIECBAgQIAAAQIEGgtIzjcGF44AAQIECBAgQIAAAQIECBAgQIAAAQIECEjOWwMECBAgQIAAAQIECBAgQIAAAQIECBAgQKCxgOR8Y3DhCBAgQIAAAQIECBAgQIAAAQIECBAgQICA5Lw1QIAAAQIECBAgQIAAAQIECBAgQIAAAQIEGgtIzjcGF44AAQIECBAgQIAAAQIECBAgQIAAAQIECEjOWwMECBAgQIAAAQIECBAgQIAAAQIECBAgQKCxgOR8Y3DhCBAgQIAAAQIECBAgQIAAAQIECBAgQICA5Lw1QIAAAQIECBAgQIAAAQIECBAgQIAAAQIEGgtIzjcGF44AAQIECBAgQIAAAQIECBAgQIAAAQIECEjOWwMECBAgQIAAAQIECBAgQIAAAQIECBAgQKCxgOR8Y3DhCBAgQIAAAQIECBAgQIAAAQIECBAgQICA5Lw1QIAAAQIECBAgQIAAAQIECBAgQIAAAQIEGgtIzjcGF44AAQIECBAgQIAAAQIECBAgQIAAAQIECEjOWwMECBAgQIAAAQIECBAgQIAAAQIECBAgQKCxgOR8Y3DhCBAgQIAAAQIECBAgQIAAAQIECBAgQICA5Lw1QIAAAQIECBAgQIAAAQIECBAgQIAAAQIEGgtIzjcGF44AAQIECBAgQIAAAQIECBAgQIAAAQIECEjOWwMECBAgQIAAAQIECBAgQIAAAQIECBAgQKCxgOR8Y3DhCBAgQIAAAQIECBAgQIAAAQIECBAgQICA5Lw1QIAAAQIECBAgQIAAAQIECBAgQIAAAQIEGgtIzjcGF44AAQIECBAgQIAAAQIECBAgQIAAAQIECEjOWwMECBAgQIAAAQIECBAgQIAAAQIECBAgQKCxgOR8Y3DhCBAgQIAAAQIECBAgQIAAAQIECBAgQICA5Lw1QIAAAQIECBAgQIAAAQIECBAgQIAAAQIEGgtIzjcGF44AAQIECBAgQIAAAQIECBAgQIAAAQIECEjOWwMECBAgQIAAAQIECBAgQIAAAQIECBAgQKCxgOR8Y3DhCBAgQIAAAQIECBAgQIAAAQIECBAgQICA5Lw1QIAAAQIECBAgQIAAAQIECBAgQIAAAQIEGgtIzjcGF44AAQIECBAgQIAAAQIECBAgQIAAAQIECEjOWwMECBAgQIAAAQIECBAgQIAAAQIECBAgQKCxgOR8Y3DhCBAgQIAAAQIECBAgQIAAAQIECBAgQICA5Lw1QIAAAQIECBAgQIAAAQIECBAgQIAAAQIEGgtIzjcGF44AAQIECBAgQIAAAQIECBAgQIAAAQIECEjOWwMECBAgQIAAAQIECBAgQIAAAQIECBAgQKCxgOR8Y3DhCBAgQIAAAQIECBAgQIAAAQIECBAgQICA5Lw1QIAAAQIECBAgQIAAAQIECBAgQIAAAQIEGgtIzjcGF44AAQIECBAgQIAAAQIECBAgQIAAAQIECEjOWwMECBAgQIAAAQIECBAgQIAAAQIECBAgQKCxgOR8Y3DhCBAgQIAAAQIECBAgQIAAAQIECBAgQICA5Lw1QIAAAQIECBAgQIAAAQIECBAgQIAAAQIEGgtIzjcGF44AAQIECBAgQIAAAQIECBAgQIAAAQIECEjOWwMECBAgQIAAAQIECBAgQIAAAQIECBAgQKCxgOR8Y3DhCBAgQIAAAQIECBAgQIAAAQIECBAgQICA5Lw1QIAAAQIECBAgQIAAAQIECBAgQIAAAQIEGgtIzjcGF44AAQIECBAgQIAAAQIECBAgQIAAAQIECEjOWwMECBAgQIAAAQIECBAgQIAAAQIECBAgQKCxgOR8Y3DhCBAgQIAAAQIECBAgQIAAAQIECBAgQICA5Lw1QIAAAQIECBAgQIAAAQIECBAgQIAAAQIEGgtIzjcGF44AAQIECBAgQIAAAQIECBAgQIAAAQIECEjOWwMECBAgQIAAAQIECBAgQIAAAQIECBAgQKCxgOR8Y3DhCBAgQIAAAQIECBAgQIAAAQIECBAgQICA5Lw1QIAAAQIECBAgQIAAAQIECBAgQIAAAQIEGgtIzjcGF44AAQIECBAgQIAAAQIECBAgQIAAAQIECEjOWwMECBAgQIAAAQIECBAgQIAAAQIECBAgQKCxgOR8Y3DhCBAgQIAAAQIECBAgQIAAAQIECBAgQICA5Lw1QIAAAQIECBAgQIAAAQIECBAgQIAAAQIEGgtIzjcGF44AAQIECBAgQIAAAQIECBAgQIAAAQIECEjOWwMECBAgQIAAAQIECBAgQIAAAQIECBAgQKCxgOR8Y3DhCBAgQIAAAQIECBAgQIAAAQIECBAgQICA5Lw1QIAAAQIECBAgQIAAAQIECBAgQIAAAQIEGgtIzjcGF44AAQIECBAgQIAAAQIECBAgQIAAAQIECEjOWwMECBAgQIAAAQIECBAgQIAAAQIECBAgQKCxgOR8Y3DhCBAgQIAAAQIECBAgQIAAAQIECBAgQICA5Lw1QIAAAQIECBAgQIAAAQIECBAgQIAAAQIEGgtIzjcGF44AAQIECBAgQIAAAQIECBAgQIAAAQIECEjOWwMECBAgQIAAAQIECBAgQIAAAQIECBAgQKCxgOR8Y3DhCBAgQIAAAQIECBAgQIAAAQIECBAgQICA5Lw1QIAAAQIECBAgQIAAAQIECBAgQIAAAQIEGgtIzjcGF44AAQIECBAgQIAAAQIECBAgQIAAAQIECEjOWwMECBAgQIAAAQIECBAgQIAAAQIECBAgQKCxgOR8Y3DhCBAgQIAAAQIECBAgQIAAAQIECBAgQICA5Lw1QIAAAQIECBAgQIAAAQIECBAgQIAAAQIEGgtIzjcGF44AAQIECBAgQIAAAQIECBAgQIAAAQIECEjOWwMECBAgQIAAAQIECBAgQIAAAQIECBAgQKCxgOR8Y3DhCBAgQIAAAQIECBAgQIAAAQIECBAgQICA5Lw1QIAAAQIECBAgQIAAAQIECBAgQIAAAQIEGgtIzjcGF44AAQIECBAgQIAAAQIECBAgQIAAAQIECEjOWwMECBAgQIAAAQIECBAgQIAAAQIECBAgQKCxgOR8Y3DhCBAgQIAAAQIECBAgQIAAAQIECBAgQICA5Lw1QIAAAQIECBAgQIAAAQIECBAgQIAAAQIEGgtIzjcGF44AAQIECBAgQIAAAQIECBAgQIAAAQIECEjOWwMECBAgQIAAAQIECBAgQIAAAQIECBAgQKCxgOR8Y3DhCBAgQIAAAQIECBAgQIAAAQIECBAgQICA5Lw1QIAAAQIECBAgQIAAAQIECBAgQIAAAQIEGgtIzjcGF44AAQIECBAgQIAAAQIECBAgQIAAAQIECEjOWwMECBAgQIAAAQIECBAgQIAAAQIECBAgQKCxgOR8Y3DhCBAgQIAAAQIECBAgQIAAAQIECBAgQICA5Lw1QIAAAQIECBAgQIAAAQIECBAgQIAAAQIEGgtIzjcGF44AAQIECBAgQIAAAQIECBAgQIAAAQIECEjOWwMECBAgQIAAAQIECBAgQIAAAQIECBAgQKCxgOR8Y3DhCBAgQIAAAQIECBAgQIAAAQIECBAgQICA5Lw1QIAAAQIECBAgQIAAAQIECBAgQIAAAQIEGgtIzjcGF44AAQIECBAgQIAAAQIECBAgQIAAAQIECEjOWwMECBAgQIAAAQIECBAgQIAAAQIECBAgQKCxgOR8Y3DhCBAgQIAAAQIECBAgQIAAAQIECBAgQICA5Lw1QIAAAQIECBAgQIAAAQIECBAgQIAAAQIEGgtIzjcGF44AAQIECBAgQIAAAQIECBAgQIAAAQIECEjOWwMECBAgQIAAAQIECBAgQIAAAQIECBAgQKCxgOR8Y3DhCBAgQIAAAQIECBAgQIAAAQIECBAgQICA5Lw1QIAAAQIECBAgQIAAAQIECBAgQIAAAQIEGgtIzjcGF44AAQIECBAgQIAAAQIECBAgQIAAAQIECEjOWwMECBAgQIAAAQIECBAgQIAAAQIECBAgQKCxgOR8Y3DhCBAgQIAAAQIECBAgQIAAAQIECBAgQICA5Lw1QIAAAQIECBAgQIAAAQIECBAgQIAAAQIEGgtIzjcGF44AAQIECBAgQIAAAQIECBAgQIAAAQIECEjOWwMECBAgQIAAAQIECBAgQIAAAQIECBAgQKCxgOR8Y3DhCBAgQIAAAQIECBAgQIAAAQIECBAgQICA5Lw1QIAAAQIECBAgQIAAAQIECBAgQIAAAQIEGgtIzjcGF44AAQIECBAgQIAAAQIECBAgQIAAAQIECEjOWwMECBAgQIAAAQIECBAgQIAAAQIECBAgQKCxgOR8Y3DhCBAgQIAAAQIECBAgQIAAAQIECBAgQICA5Lw1QIAAAQIECBAgQIAAAQIECBAgQIAAAQIEGgtIzjcGF44AAQIECBAgQIAAAQIECBAgQIAAAQIECEjOWwMECBAgQIAAAQIECBAgQIAAAQIECBAgQKCxgOR8Y3DhCBAgQIAAAQIECBAgQIAAAQIECBAgQICA5Lw1QIAAAQIECBAgQIAAAQIECBAgQIAAAQIEGgtIzjcGF44AAQIECBAgQIAAAQIECBAgQIAAAQIECEjOWwMECBAgQIAAAQIECBAgQIAAAQIECBAgQKCxgOR8Y3DhCBAgQIAAAQIECBAgQIAAAQIECBAgQICA5Lw1QIAAAQIECBAgQIAAAQIECBAgQIAAAQIEGgtIzjcGF44AAQIECBAgQIAAAQIECBAgQIAAAQIECEjOWwMECBAgQIAAAQIECBAgQIAAAQIECBAgQKCxgOR8Y3DhCBAgQIAAAQIECBAgQIAAAQIECBAgQICA5Lw1QIAAAQIECBAgQIAAAQIECBAgQIAAAQIEGgtIzjcGF44AAQIECBAgQIAAAQIECBAgQIAAAQIECEjOWwMECBAgQIAAAQIECBAgQIAAAQIECBAgQKCxgOR8Y3DhCBAgQIAAAQIECBAgQIAAAQIECBAgQICA5Lw1QIAAAQIECBAgQIAAAQIECBAgQIAAAQIEGgtIzjcGF44AAQIECBAgQIAAAQIECBAgQIAAAQIECEjOWwMECBAgQIAAAQIECBAgQIAAAQIECBAgQKCxgOR8Y3DhCBAgQIAAAQIECBAgQIAAAQIECBAgQICA5Lw1QIAAAQIECBAgQIAAAQIECBAgQIAAAQIEGgtIzjcGF44AAQIECBAgQIAAAQIECBAgQIAAAQIECEjOWwMECBAgQIAAAQIECBAgQIAAAQIECBAgQKCxgOR8Y3DhCBAgQIAAAQIECBAgQIAAAQIECBAgQICA5Lw1QIAAAQIECBAgQIAAAQIECBAgQIAAAQIEGgtIzjcGF44AAQIECBAgQIAAAQIECBAgQIAAAQIECEjOWwMECBAgQIAAAQIECBAgQIAAAQIECBAgQKCxgOR8Y3DhCBAgQIAAAQIECBAgQIAAAQIECBAgQICA5Lw1QIAAAQIECBAgQIAAAQIECBAgQIAAAQIEGgtIzjcGF44AAQIECBAgQIAAAQIECBAgQIAAAQIECEjOWwMECBAgQIAAAQIECBAgQIAAAQIECBAgQKCxgOR8Y3DhCBAgQIAAAQIECBAgQIAAAQIECBAgQICA5Lw1QIAAAQIECBAgQIAAAQIECBAgQIAAAQIEGgtIzjcGF44AAQIECBAgQIAAAQIECBAgQIAAAQIECEjOWwMECBAgQIAAAQIECBAgQIAAAQIECBAgQKCxgOR8Y3DhCBAgQIAAAQIECBAgQIAAAQIECBAgQICA5Lw1QIAAAQIECBAgQIAAAQIECBAgQIAAAQIEGgtIzjcGF44AAQIECBAgQIAAAQIECBAgQIAAAQIECEjOWwMECBAgQIAAAQIECBAgQIAAAQIECBAgQKCxgOR8Y3DhCBAgQIAAAQIECBAgQIAAAQIECBAgQICA5Lw1QIAAAQIECBAgQIAAAQIECBAgQIAAAQIEGgtIzjcGF44AAQIECBAgQIAAAQIECBAgQIAAAQIECEjOWwMECBAgQIAAAQIECBAgQIAAAQIECBAgQKCxgOR8Y3DhCBAgQIAAAQIECBAgQIAAAQIECBAgQICA5Lw1QIAAAQIECBAgQIAAAQIECBAgQIAAAQIEGgtIzjcGF44AAQIECBAgQIAAAQIECBAgQIAAAQIECEjOWwMECBAgQIAAAQIECBAgQIAAAQIECBAgQKCxgOR8Y3DhCBAgQIAAAQIECBAgQIAAAQIECBAgQICA5Lw1QIAAAQIECBAgQIAAAQIECBAgQIAAAQIEGgtIzjcGF44AAQIECBAgQIAAAQIECBAgQIAAAQIECEjOWwMECBAgQIAAAQIECBAgQIAAAQIECBAgQKCxgOR8Y3DhCBAgQIAAAQIECBAgQIAAAQIECBAgQICA5Lw1QIAAAQIECBAgQIAAAQIECBAgQIAAAQIEGgtIzjcGF44AAQIECBAgQIAAAQIECBAgQIAAAQIECEjOWwMECBAgQIAAAQIECBAgQIAAAQIECBAgQKCxgOR8Y3DhCBAgQIAAAQIECBAgQIAAAQIECBAgQICA5Lw1QIAAAQIECBAgQIAAAQIECBAgQIAAAQIEGgtIzjcGF44AAQIECBAgQIAAAQIECBAgQIAAAQIECEjOWwMECBAgQIAAAQIECBAgQIAAAQIECBAgQKCxgOR8Y3DhCBAgQIAAAQIECBAgQIAAAQIECBAgQICA5Lw1QIAAAQIECBAgQIAAAQIECBAgQIAAAQIEGgtIzjcGF44AAQIECBAgQIAAAQIECBAgQIAAAQIECEjOWwMECBAgQIAAAQIECBAgQIAAAQIECBAgQKCxgOR8Y3DhCBAgQIAAAQIECBAgQIAAAQIECBAgQICA5Lw1QIAAAQIECBAgQIAAAQIECBAgQIAAAQIEGgtIzjcGF44AAQIECBAgQIAAAQIECBAgQIAAAQIECEjOWwMECBAgQIAAAQIECBAgQIAAAQIECBAgQKCxgOR8Y3DhCBAgQIAAAQIECBAgQIAAAQIECBAgQICA5Lw1QIAAAQIECBAgQIAAAQIECBAgQIAAAQIEGgtIzjcGF44AAQIECBAgQIAAAQIECBAgQIAAAQIECEjOWwMECBAgQIAAAQIECBAgQIAAAQIECBAgQKCxgOR8Y3DhCBAgQIAAAQIECBAgQIAAAQIECBAgQICA5Lw1QIAAAQIECBAgQIAAAQIECBAgQIAAAQIEGgtIzjcGF44AAQIECBAgQIAAAQIECBAgQIAAAQIECEjOWwMECBAgQIAAAQIECBAgQIAAAQIECBAgQKCxgOR8Y3DhCBAgQIAAAQIECBAgQIAAAQIECBAgQICA5Lw1QIAAAQIECBAgQIAAAQIECBAgQIAAAQIEGgtIzjcGF44AAQIECBAgQIAAAQIECBAgQIAAAQIECEjOWwMECBAgQIAAAQIECBAgQIAAAQIECBAgQKCxgOR8Y3DhCBAgQIAAAQIECBAgQIAAAQIECBAgQICA5Lw1QIAAAQIECBAgQIAAAQIECBAgQIAAAQIEGgtIzjcGF44AAQIECBAgQIAAAQIECBAgQIAAAQIECEjOWwMECBAgQIAAAQIECBAgQIAAAQIECBAgQKCxgOR8Y3DhCBAgQIAAAQIECBAgQIAAAQIECBAgQICA5Lw1QIAAAQIECBAgQIAAAQIECBAgQIAAAQIEGgtIzjcGF44AAQIECBAgQIAAAQIECBAgQIAAAQIECEjOWwMECBAgQIAAAQIECBAgQIAAAQIECBAgQKCxgOR8Y3DhCBAgQIAAAQIECBAgQIAAAQIECBAgQICA5Lw1QIAAAQIECBAgQIAAAQIECBAgQIAAAQIEGgtIzjcGF44AAQIECBAgQIAAAQIECBAgQIAAAQIECEjOWwMECBAgQIAAAQIECBAgQIAAAQIECBAgQKCxgOR8Y3DhCBAgQIAAAQIECBAgQIAAAQIECBAgQICA5Lw1QIAAAQIECBAgQIAAAQIECBAgQIAAAQIEGgtIzjcGF44AAQIECBAgQIAAAQIECBAgQIAAAQIECEjOWwMECBAgQIAAAQIECBAgQIAAAQIECBAgQKCxgOR8Y3DhCBAgQIAAAQIECBAgQIAAAQIECBAgQICA5Lw1QIAAAQIECBAgQIAAAQIECBAgQIAAAQIEGgtIzjcGF44AAQIECBAgQIAAAQIECBAgQIAAAQIECEjOWwMECBAgQIAAAQIECBAgQIAAAQIECBAgQKCxgOR8Y3DhCBAgQIAAAQIECBAgQIAAAQIECBAgQICA5Lw1QIAAAQIECBAgQIAA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QKCMgHK+TBQGIUCAAAECBAgQIECAAAECBAgQIECAAIEuAsr5LknbkwABAgQIECBAgAABAgQIECBAgAABAgTKCCjny0RhEAIECBAgQIAAAQIECBAgQIAAAQIECBDoIqCc75K0PQkQIECAAAECBAgQIECAAAECBAgQIECgjIByvkwUBiFAgAABAgQIECBAgAABAgQIECBAgACBLgLK+S5J25MAAQIECBAgQIAAAQIECBAgQIAAAQIEyggo58tEYRACBAgQIECAAAECBAgQIECAAAECBAgQ6CKgnO+StD0JECBAgAABAgQIECBAgAABAgQIECBAoIyAcr5MFAYhQIAAAQIECBAgQIAAAQIECBAgQIAAgS4CyvkuSduTAAECBAgQIECAAAECBAgQIECAAAECBMoIKOfLRGEQAgQIECBAgAABAgQIECBAgAABAgQIEOgioJzvkrQ9CRAgQIAAAQIECBAgQIAAAQIECBAgQKCMgHK+TBQGIUCAAAECBAgQIECAAAECBAgQIECAAIEuAsr5LknbkwABAgQIECBAgAABAgQIECBAgAABAgTKCCjny0RhEAIECBAgQIAAAQIECBAgQIAAAQIECBDoIqCc75K0PQkQIECAAAECBAgQIECAAAECBAgQIECgjIByvkwUBiFAgAABAgQIECBAgAABAgQIECBAgACBLgLK+S5J25MAAQIECBAgQIAAAQIECBAgQIAAAQIEyggo58tEYRACBAgQIECAAAECBAgQIECAAAECBAgQ6CKgnO+StD0JECBAgAABAgQIECBAgAABAgQIECBAoIyAcr5MFAYhQIAAAQIECBAgQIAAAQIECBAgQIAAgS4CyvkuSduTAAECBAgQIECAAAECBAgQIECAAAECBMoIKOfLRGEQAgQIECBAgAABAgQIECBAgAABAgQIEOgioJzvkrQ9CRAgQIAAAQIECBAgQIAAAQIECBAgQKCMgHK+TBQGIUCAAAECBAgQIECAAAECBAgQIECAAIEuAsr5LknbkwABAgQIECBAgAABAgQIECBAgAABAgTKCCjny0RhEAIECBAgQIAAAQIECBAgQIAAAQIECBDoIqCc75K0PQkQIECAAAECBAgQIECAAAECBAgQIECgjIByvkwUBiFAgAABAgQIECBAgAABAgQIECBAgACBLgLK+S5J25MAAQIECBAgQIAAAQIECBAgQIAAAQIEyggo58tEYRACBAgQIECAAAECBAgQIECAAAECBAgQ6CKgnO+StD0JECBAgAABAgQIECBAgAABAgQIECBAoIyAcr5MFAYhQIAAAQIECBAgQIAAAQIECBAgQIAAgS4CyvkuSduTAAECBAgQIECAAAECBAgQIECAAAECBMoIKOfLRGEQAgQIECBAgAABAgQIECBAgAABAgQIEOgioJzvkrQ9CRAgQIAAAQIECBAgQIAAAQIECBAgQKCMgHK+TBQGIUCAAAECBAgQIECAAAECBAgQIECAAIEuAsr5LknbkwABAgQIECBAgAABAgQIECBAgAABAgTKCCjny0RhEAIECBAgQIAAAQIECBAgQIAAAQIECBDoIqCc75K0PQkQIECAAAECBAgQIECAAAECBAgQIECgjIByvkwUBiFAgAABAgQIECBAgAABAgQIECBAgACBLgLK+S5J25MAAQIECBAgQIAAAQIECBAgQIAAAQIEyggo58tEYRACBAgQIECAAAECBAgQIECAAAECBAgQ6CKgnO+StD0JECBAgAABAgQIECBAgAABAgQIECBAoIyAcr5MFAYhQIAAAQIECBAgQIAAAQIECBAgQIAAgS4CyvkuSduTAAECBAgQIECAAAECBAgQIECAAAECBMoIKOfLRGEQAgQIECBAgAABAgQIECBAgAABAgQIEOgioJzvkrQ9CRAgQIAAAQIECBAgQIAAAQIECBAgQKCMgHK+TBQGIUCAAAECBAgQIECAAAECBAgQIECAAIEuAsr5LknbkwABAgQIECBAgAABAgQIECBAgAABAgTKCCjny0RhEAIECBAgQIAAAQIECBAgQIAAAQIECBDoIqCc75K0PQkQIECAAAECBAgQIECAAAECBAgQIECgjIByvkwUBiFAgAABAgQIECBAgAABAgQIECBAgACBLgLK+S5J25MAAQIECBAgQIAAAQIECBAgQIAAAQIEyggo58tEYRACBAgQIECAAAECBAgQIECAAAECBAgQ6CKgnO+StD0JECBAgAABAgQIECBAgAABAgQIECBAoIyAcr5MFAYhQIAAAQIECBAgQIAAAQIECBAgQIAAgS4CyvkuSduTAAECBAgQIECAAAECBAgQIECAAAECBMoIKOfLRGEQAgQIECBAgAABAgQIECBAgAABAgQIEOgioJzvkrQ9CRAgQIAAAQIECBAgQIAAAQIECBAgQKCMgHK+TBQGIUCAAAECBAgQIECAAAECBAgQIECAAIEuAsr5LknbkwABAgQIECBAgAABAgQIECBAgAABAgTKCCjny0RhEAIECBAgQIAAAQIECBAgQIAAAQIECBDoIqCc75K0PQkQIECAAAECBAgQIECAAAECBAgQIECgjIByvkwUBiFAgAABAgQIECBAgAABAgQIECBAgACBLgLK+S5J25MAAQIECBAgQIAAAQIECBAgQIAAAQIEyggo58tEYRACBAgQIECAAAECBAgQIECAAAECBAgQ6CKgnO+StD0JECBAgAABAgQIECBAgAABAgQIECBAoIyAcr5MFAYhQIAAAQIECBAgQIAAAQIECBAgQIAAgS4CyvkuSduTAAECBAgQIECAAAECBAgQIECAAAECBMoIKOfLRGEQAgQIECBAgAABAgQIECBAgAABAgQIEOgioJzvkrQ9CRAgQIAAAQIECBAgQIAAAQIECBAgQKCMgHK+TBQGIUCAAAECBAgQIECAAAECBAgQIECAAIEuAsr5LknbkwABAgQIECBAgAABAgQIECBAgAABAgTKCCjny0RhEAIECBAgQIAAAQIECBAgQIAAAQIECBDoIqCc75K0PQkQIECAAAECBAgQIECAAAECBAgQIECgjIByvkwUBiFAgAABAgQIECBAgAABAgQIECBAgACBLgLK+S5J25MAAQIECBAgQIAAAQIECBAgQIAAAQIEyggo58tEYRACBAgQIECAAAECBAgQIECAAAECBAgQ6CKgnO+StD0JECBAgAABAgQIECBAgAABAgQIECBAoIyAcr5MFAYhQIAAAQIECBAgQIAAAQIECBAgQIAAgS4CyvkuSduTAAECBAgQIECAAAECBAgQIECAAAECBMoIKOfLRGEQAgQIECBAgAABAgQIECBAgAABAgQIEOgioJzvkrQ9CRAgQIAAAQIECBAgQIAAAQIECBAgQKCMgHK+TBQGIUCAAAECBAgQIECAAAECBAgQIECAAIEuAsr5LknbkwABAgQIECBAgAABAgQIECBAgAABAgTKCCjny0RhEAIECBAgQIAAAQIECBAgQIAAAQIECBDoIqCc75K0PQkQIECAAAECBAgQIECAAAECBAgQIECgjIByvkwUBiFAgAABAgQIECBAgAABAgQIECBAgACBLgLK+S5J25MAAQIECBAgQIAAAQIECBAgQIAAAQIEyggo58tEYRACBAgQIECAAAECBAgQIECAAAECBAgQ6CKgnO+StD0JECBAgAABAgQIECBAgAABAgQIECBAoIyAcr5MFAYhQIAAAQIECBAgQIAAAQIECBAgQIAAgS4CyvkuSduTAAECBAgQIECAAAECBAgQIECAAAECBMoIKOfLRGEQAgQIECBAgAABAgQIECBAgAABAgQIEOgioJzvkrQ9CRAgQIAAAQIECBAgQIAAAQIECBAgQKCMgHK+TBQGIUCAAAECBAgQIECAAAECBAgQIECAAIEuAsr5LknbkwABAgQIECBAgAABAgQIECBAgAABAgTKCCjny0RhEAIECBAgQIAAAQIECBAgQIAAAQIECBDoIqCc75K0PQkQIECAAAECBAgQIECAAAECBAgQIECgjIByvkwUBiFAgAABAgQIECBAgAABAgQIECBAgACBLgLK+S5J25MAAQIECBAgQIAAAQIECBAgQIAAAQIEyggo58tEYRACBAgQIECAAAECBAgQIECAAAECBAgQ6CKgnO+StD0JECBAgAABAgQIECBAgAABAgQIECBAoIyAcr5MFAYhQIAAAQIECBAgQIAAAQIECBAgQIAAgS4CyvkuSduTAAECBAgQIECAAAECBAgQIECAAAECBMoIKOfLRGEQAgQIECBAgAABAgQIECBAgAABAgQIEOgioJzvkrQ9CRAgQIAAAQIECBAgQIAAAQIECBAgQKCMgHK+TBQGIUCAAAECBAgQIECAAAECBAgQIECAAIEuAsr5LknbkwABAgQIECBAgAABAgQIECBAgAABAgTKCCjny0RhEAIECBAgQIAAAQIECBAgQIAAAQIECBDoIqCc75K0PQkQIECAAAECBAgQIECAAAECBAgQIECgjIByvkwUBiFAgAABAgQIECBAgAABAgQIECBAgACBLgLK+S5J25MAAQIECBAgQIAAAQIECBAgQIAAAQIEyggo58tEYRACBAgQIECAAAECBAgQIECAAAECBAgQ6CKgnO+StD0JECBAgAABAgQIECBAgAABAgQIECBAoIyAcr5MFAYhQIAAAQIECBAgQIAAAQIECBAgQIAAgS4CyvkuSduTAAECBAgQIECAAAECBAgQIECAAAECBMoIKOfLRGEQAgQIECBAgAABAgQIECBAgAABAgQIEOgioJzvkrQ9CRAgQIAAAQIECBAgQIAAAQIECBAgQKCMgHK+TBQGIUCAAAECBAgQIECAAAECBAgQIECAAIEuAsr5LknbkwABAgQIECBAgAABAgQIECBAgAABAgTKCCjny0RhEAIECBAgQIAAAQIECBAgQIAAAQIECBDoIqCc75K0PQkQIECAAAECBAgQIECAAAECBAgQIECgjIByvkwUBiFAgAABAgQIECBAgAABAgQIECBAgACBLgLK+S5J25MAAQIECBAgQIAAAQIECBAgQIAAAQIEyggo58tEYRACBAgQIECAAAECBAgQIECAAAECBAgQ6CKgnO+StD0JECBAgAABAgQIECBAgAABAgQIECBAoIyAcr5MFAYhQIAAAQIECBAgQIAAAQIECBAgQIAAgS4CyvkuSduTAAECBAgQIECAAAECBAgQIECAAAECBMoIKOfLRGEQAgQIECBAgAABAgQIECBAgAABAgQIEOgioJzvkrQ9CRAgQIAAAQIECBAgQIAAAQIECBAgQKCMgHK+TBQGIUCAAAECBAgQIECAAAECBAgQIECAAIEuAsr5LknbkwABAgQIECBAgAABAni11LsAAAqWSURBVAQIECBAgAABAgTKCCjny0RhEAIECBAgQIAAAQIECBAgQIAAAQIECBDoIqCc75K0PQkQIECAAAECBAgQIECAAAECBAgQIECgjIByvkwUBiFAgAABAgQIECBAgAABAgQIECBAgACBLgLK+S5J25MAAQIECBAgQIAAAQIECBAgQIAAAQIEyggo58tEYRACBAgQIECAAAECBAgQIECAAAECBAgQ6CKgnO+StD0JECBAgAABAgQIECBAgAABAgQIECBAoIyAcr5MFAYhQIAAAQIECBAgQIAAAQIECBAgQIAAgS4CyvkuSduTAAECBAgQIECAAAECBAgQIECAAAECBMoIKOfLRGEQAgQIECBAgAABAgQIECBAgAABAgQIEOgioJzvkrQ9CRAgQIAAAQIECBAgQIAAAQIECBAgQKCMgHK+TBQGIUCAAAECBAgQIECAAAECBAgQIECAAIEuAsr5LknbkwABAgQIECBAgAABAgQIECBAgAABAgTKCCjny0RhEAIECBAgQIAAAQIECBAgQIAAAQIECBDoIqCc75K0PQkQIECAAAECBAgQIECAAAECBAgQIECgjIByvkwUBiFAgAABAgQIECBAgAABAgQIECBAgACBLgLK+S5J25MAAQIECBAgQIAAAQIECBAgQIAAAQIEyggo58tEYRACBAgQIECAAAECBAgQIECAAAECBAgQ6CKgnO+StD0JECBAgAABAgQIECBAgAABAgQIECBAoIyAcr5MFAYhQIAAAQIECBAgQIAAAQIECBAgQIAAgS4CyvkuSduTAAECBAgQIECAAAECBAgQIECAAAECBMoIKOfLRGEQAgQIECBAgAABAgQIECBAgAABAgQIEOgioJzvkrQ9CRAgQIAAAQIECBAgQIAAAQIECBAgQKCMgHK+TBQGIUCAAAECBAgQIECAAAECBAgQIECAAIEuAsr5LknbkwABAgQIECBAgAABAgQIECBAgAABAgTKCCjny0RhEAIECBAgQIAAAQIECBAgQIAAAQIECBDoIqCc75K0PQkQIECAAAECBAgQIECAAAECBAgQIECgjIByvkwUBiFAgAABAgQIECBAgAABAgQIECBAgACBLgLK+S5J25MAAQIECBAgQIAAAQIECBAgQIAAAQIEyggo58tEYRACBAgQIECAAAECBAgQIECAAAECBAgQ6CKgnO+StD0JECBAgAABAgQIECBAgAABAgQIECBAoIyAcr5MFAYhQIAAAQIECBAgQIAAAQIECBAgQIAAgS4CyvkuSduTAAECBAgQIECAAAECBAgQIECAAAECBMoIKOfLRGEQAgQIECBAgAABAgQIECBAgAABAgQIEOgioJzvkrQ9CRAgQIAAAQIECBAgQIAAAQIECBAgQKCMgHK+TBQGIUCAAAECBAgQIECAAAECBAgQIECAAIEuAsr5LknbkwABAgQIECBAgAABAgQIECBAgAABAgTKCCjny0RhEAIECBAgQIAAAQIECBAgQIAAAQIECBDoIqCc75K0PQkQIECAAAECBAgQIECAAAECBAgQIECgjIByvkwUBiFAgAABAgQIECBAgAABAgQIECBAgACBLgLK+S5J25MAAQIECBAgQIAAAQIECBAgQIAAAQIEyggo58tEYRACBAgQIECAAAECBAgQIECAAAECBAgQ6CKgnO+StD0JECBAgAABAgQIECBAgAABAgQIECBAoIyAcr5MFAYhQIAAAQIECBAgQIAAAQIECBAgQIAAgS4CyvkuSduTAAECBAgQIECAAAECBAgQIECAAAECBMoIKOfLRGEQAgQIECBAgAABAgQIECBAgAABAgQIEOgioJzvkrQ9CRAgQIAAAQIECBAgQIAAAQIECBAgQKCMgHK+TBQGIUCAAAECBAgQIECAAAECBAgQIECAAIEuAsr5LknbkwABAgQIECBAgAABAgQIECBAgAABAgTKCCjny0RhEAIECBAgQIAAAQIECBAgQIAAAQIECBDoIqCc75K0PQkQIECAAAECBAgQIECAAAECBAgQIECgjIByvkwUBiFAgAABAgQIECBAgAABAgQIECBAgACBLgLK+S5J25MAAQIECBAgQIAAAQIECBAgQIAAAQIEyggo58tEYRACBAgQIECAAAECBAgQIECAAAECBAgQ6CKgnO+StD0JECBAgAABAgQIECBAgAABAgQIECBAoIyAcr5MFAYhQIAAAQIECBAgQIAAAQIECBAgQIAAgS4CyvkuSduTAAECBAgQIECAAAECBAgQIECAAAECBMoIKOfLRGEQAgQIECBAgAABAgQIECBAgAABAgQIEOgioJzvkrQ9CRAgQIAAAQIECBAgQIAAAQIECBAgQKCMgHK+TBQGIUCAAAECBAgQIECAAAECBAgQIECAAIEuAsr5LknbkwABAgQIECBAgAABAgQIECBAgAABAgTKCCjny0RhEAIECBAgQIAAAQIECBAgQIAAAQIECBDoIqCc75K0PQkQIECAAAECBAgQIECAAAECBAgQIECgjIByvkwUBiFAgAABAgQIECBAgAABAgQIECBAgACBLgLK+S5J25MAAQIECBAgQIAAAQIECBAgQIAAAQIEyggo58tEYRACBAgQIECAAAECBAgQIECAAAECBAgQ6CKgnO+StD0JECBAgAABAgQIECBAgAABAgQIECBAoIyAcr5MFAYhQIAAAQIECBAgQIAAAQIECBAgQIAAgS4CyvkuSduTAAECBAgQIECAAAECBAgQIECAAAECBMoIKOfLRGEQAgQIECBAgAABAgQIECBAgAABAgQIEOgioJzvkrQ9CRAgQIAAAQIECBAgQIAAAQIECBAgQKCMgHK+TBQGIUCAAAECBAgQIECAAAECBAgQIECAAIEuAsr5LknbkwABAgQIECBAgAABAgQIECBAgAABAgTKCCjny0RhEAIECBAgQIAAAQIECBAgQIAAAQIECBDoIqCc75K0PQkQIECAAAECBAgQIECAAAECBAgQIECgjIByvkwUBiFAgAABAgQIECBAgAABAgQIECBAgACBLgLK+S5J25MAAQIECBAgQIAAAQIECBAgQIAAAQIEyggo58tEYRACBAgQIECAAAECBAgQIECAAAECBAgQ6CKgnO+StD0JECBAgAABAgQIECBAgAABAgQIECBAoIyAcr5MFAYhQIAAAQIECBAgQIAAAQIECBAgQIAAgS4CyvkuSduTAAECBAgQIECAAAECBAgQIECAAAECBMoIKOfLRGEQAgQIECBAgAABAgQIECBAgAABAgQIEOgioJzvkrQ9CRAgQIAAAQIECBAgQIAAAQIECBAgQKCMgHK+TBQGIUCAAAECBAgQIECAAAECBAgQIECAAIEuAsr5LknbkwABAgQIECBAgAABAgQIECBAgAABAgTKCCjny0RhEAIECBAgQIAAAQIECBAgQIAAAQIECBDoIqCc75K0PQkQIECAAAECBAgQIECAAAECBAgQIECgjIByvkwUBiFAgAABAgQIECBAgAABAgQIECBAgACBLgLK+S5J25MAAQIECBAgQIAAAQIECBAgQIAAAQIEyggo58tEYRACBAgQIECAAAECBAgQIECAAAECBAgQ6CLw31Q/jVm7EW6gAAAAAElFTkSuQmCC'

def readb64(base64_string):
    sbuf = BytesIO()
    sbuf.write(base64.b64decode(base64_string))
    sbuf.seek(0)
    # img = Image.open(sbuf)
    img = imread(sbuf)
    img = img[:, :, 3]
    img = img.astype('float32')
    img /= 255.0
    img = np.array(img)
    return img


def load_pic(image_path):
    img = imread(image_path)
    img = img[:, :, 3]
    img = img.astype('float32')
    img /= 255.0
    img = np.array(img)
    return img


class BalancedDataset(Dataset):
    def __init__(self, x, y, transform=None):
        self.img_names = x
        resize_transform = Compose([ToPILImage(), Resize(cropped_size[::-1]), ToTensor()])
        self.data = [resize_transform(load_pic(xi)) for xi in x]
        self.xy = []
        for i in range(criterion_number):
            self.xy.append(defaultdict(list))
            for j in range(len(x)):
                yi = y[j][i]
                # self.data[int(sum(yi) > 0.5 * criterion_number)].append((resize_transform(xi), yi))
                self.xy[i][int(yi > 0.5)].append((j, yi))
        for i in range(criterion_number):
            print(len(self.xy[i][0]), len(self.xy[i][1]))
        self.transform = transform

    def __len__(self):
        return 1

    def __getitem__(self, idx):
        lable, id_, crit = idx
        pic_num, mark = self.xy[crit][lable][id_]
        mark = random.uniform(max(0.0, mark - 0.025), min(1.0, mark + 0.025))
        mark = np.array(mark).astype('float32').reshape(1)
        sample = self.data[pic_num]
        m = 0
        sample_ = sample
        if self.transform:
            while m == 0:
                sample_ = self.transform(sample)
                m = torch.max(sample_)
        # sample = torch.clamp(sample, 0.0, 1.0)
        # sample[sample > 0] = 1
        sample_ /= torch.max(sample_)
        return sample_, mark


class DrawingDataset(Dataset):
    def __init__(self, x, y, transform=None):
        self.img_names = x
        resize_transform = Compose([ToPILImage(), Resize(cropped_size[::-1]), ToTensor()])
        self.x = [resize_transform(load_pic(xi)) for xi in x]
        print(self.x[0].shape)
        self.y = y
        self.transform = transform

    def __len__(self):
        return len(self.x)

    def __getitem__(self, idx):
        id_, crit = idx
        sample = self.x[id_]
        mark = self.y[id_][crit].reshape(1)
        sample_ = sample
        if self.transform:
            sample_ = self.transform(sample)

        # sample = torch.clamp(sample, 0.0, 1.0)
        # sample[sample > 0] = 1
        sample_ = sample_ / torch.max(sample_)
        print(sample_.shape), print(mark.shape)
        return sample_, mark

    def get_img_name(self, id_):
        return self.img_names[id_]


class OneImageDataset(Dataset):
    def __init__(self, image):
        resize_transform = Compose([ToPILImage(), Resize(cropped_size[::-1]), ToTensor()])
        self.images = [resize_transform(image)]
        print(self.images[0].shape)

    def __len__(self):
        return len(self.images)

    def __getitem__(self, idx):
        id_, crit = idx
        sample = self.images[id_]
        print(sample.shape)
        return sample / torch.max(sample), .0


class BalancedSampler(Sampler):
    def __init__(self, ds: BalancedDataset, total: int, weights=(1, 1), crit=1):
        crit -= 1
        self.weights = weights
        self.lens = {label: len(record) for label, record in ds.xy[crit].items()}
        self.total = total
        self.rng = random.Random()
        self.crit = crit

    def __len__(self):
        return self.total

    def __iter__(self):
        data = sorted(self.lens.items())
        for _ in range(len(self)):
            for label, len_ in self.rng.choices(data, weights=self.weights):
                yield label, self.rng.randrange(len_), self.crit


class DrawingSampler(Sampler):
    def __init__(self, ds: DrawingDataset, crit=1):
        crit -= 1
        self.total = len(ds)
        self.crit = crit

    def __len__(self):
        return self.total

    def __iter__(self):
        for i in range(self.total):
            yield i, self.crit


def random_ext(x):
    size = x.size
    ratio_1 = random.uniform(1, 5)
    ratio_2 = random.uniform(1, 5)
    res = Resize(size=(int(size[1] * ratio_1), int(size[0] * ratio_2)))(x)
    res = RandomCrop(size=(5 * size[1], 5 * size[0]), pad_if_needed=True)(res)
    res = Resize(size=size[::-1])(res)
    return res


def get_lr(optimizer):
    for param_group in optimizer.param_groups:
        return param_group['lr']


def train(model, crit, model_name, epochs=25000, start_epoch=1):
    train_x, train_y = load_dataset('train.pkl')
    test_x, test_y = load_dataset('test.pkl')
    model_name = model_name + str(crit)

    batch_size = 10
    batches = 5

    transform = Compose(
        [ToPILImage(), Pad((75, 30), 0), RandomAffine(degrees=15, scale=(0.6, 1.5), shear=50), Lambda(random_ext),
         RandomCrop(cropped_size[::-1]),
         RandomHorizontalFlip(),
         ToTensor()])
    train_dataset = BalancedDataset(train_x, train_y, transform=transform)
    test_dataset = DrawingDataset(test_x, test_y)
    # plt.figure(figsize=(8, 8))
    # for i in range(8):
    #     plt.subplot(4, 2, i + 1), plt.imshow(np.array(train_dataset.__getitem__((i % 2, i, crit-1))[0][0]), cmap='binary')
    # plt.show()

    trainloader = DataLoader(train_dataset, sampler=BalancedSampler(train_dataset, batch_size * batches, weights=(1, 1),
                                                                    crit=crit), batch_size=batch_size)
    testloader = DataLoader(test_dataset, sampler=DrawingSampler(test_dataset, crit=crit), batch_size=batch_size)

    best_loss = float('+Inf')
    if cont_f:
        start_epoch, best_loss = load_last(model_name, model)
    model.to(device)

    criterion = MSELoss()
    optimizer = Adadelta(model.parameters(), lr=1.0)
    scheduler = optim.lr_scheduler.CosineAnnealingWarmRestarts(optimizer, T_0=100, T_mult=1)

    with tqdm(range(start_epoch, epochs), desc='Epochs: ', position=0, initial=start_epoch, total=epochs) as pbar:
        for epoch in pbar:
            model.train()
            running_loss = 0.0
            for x, y in trainloader:
                optimizer.zero_grad()
                x = x.to(device)
                y = y.to(device)
                output = model(x)
                loss_train = criterion(output, y)
                loss_train.backward()
                optimizer.step()
                running_loss += loss_train.item()
                del output, loss_train
            running_loss /= len(trainloader)
            scheduler.step()
            # pbar.write(str(get_lr(optimizer)))

            model.eval()
            running_test_loss = 0.0
            for x, y in testloader:
                with torch.no_grad():
                    x = x.to(device)
                    y = y.to(device)
                    output = model(x)
                    loss = criterion(output, y)
                running_test_loss += loss.item()
            running_test_loss /= len(testloader)

            if best_loss > running_test_loss:
                Path('checkpoints').mkdir(exist_ok=True)
                torch.save(model.state_dict(), f'checkpoints/{model_name}_{epoch:04d}_{running_test_loss:.4f}.pth')
                pbar.write(f'Saving at epoch {epoch}, test loss: {running_test_loss}')
                best_loss = running_test_loss

            pbar.set_postfix({
                'loss': f'{running_loss:.4f}',
                'test_loss': f'{running_test_loss:.4f}'
            })


def predict_image(model, img):
    model.to(device)
    dataset = OneImageDataset(img)
    testloader = DataLoader(dataset, sampler=DrawingSampler(dataset, crit=1), batch_size=1)
    model_name = 'model' + '1'
    load_last(model_name, model)
    model.eval()
    x, y = next(iter(testloader))
    x = x.to(device)
    with torch.no_grad():
        print(x.shape)
        print(x)
        output = model(x)
    output = output.cpu()
    # y_true[:, i - 1] = y.numpy().flatten()
    print(output)
    return output.numpy().flatten()

def test(model, model_name_, val, predict_folder):
    set_name = 'test.pkl'
    if val:
        set_name = 'val.pkl'
    if predict_folder:
        test_x = [os.path.join(predict_folder, i) for i in os.listdir(predict_folder)]
        test_y = np.zeros((len(test_x), criterion_number))
    else:
        test_x, test_y = load_dataset(set_name)
    test_dataset = DrawingDataset(test_x, test_y)
    y_true = np.zeros((len(test_x), criterion_number))
    y_pred = np.zeros((len(test_x), criterion_number))
    model.to(device)
    for i in range(1, criterion_number + 1):
        testloader = DataLoader(test_dataset, sampler=DrawingSampler(test_dataset, crit=i), batch_size=len(test_x))
        model_name = model_name_ + str(i)
        load_last(model_name, model)
        model.eval()
        for x, y in testloader:
            x = x.to(device)
            with torch.no_grad():
                print(x.shape)
                # print(x)
                output = model(x)
            output = output.cpu()
            y_true[:, i - 1] = y.numpy().flatten()
            y_pred[:, i - 1] = output.numpy().flatten()
    if not predict_folder:
        for i in range(len(y_pred)):
            print(f'{test_dataset.get_img_name(i)}: {[int(round(j * 10)) for j in y_pred[i]]} {[int(round(j * 10)) for j in y_true[i]]}')

        y_true = np.array(y_true)
        y_pred = np.array(y_pred)
        print(f'mse: {((y_true - y_pred)**2).mean(axis=(0, 1))}')
    else:
        for i in range(len(y_pred)):
            print(f'{test_dataset.get_img_name(i)}: {[int(round(j * 10)) for j in y_pred[i]]}')


if __name__ == '__main__':
    parser = argparse.ArgumentParser()
    parser.add_argument('-t', '--train', action='store_const', const=True, default=False)
    parser.add_argument('-c', '--continue', action='store_const', const=True, default=False)
    parser.add_argument('-v', '--validate', action='store_const', const=True, default=False)
    parser.add_argument('-f', '--files', nargs='?')
    parser.add_argument('-n', '--number', nargs='?', type=int, default=1)
    parser.add_argument('-m', '--model', nargs='?', default='model')
    parser.add_argument('-p', '--predict', nargs='?')
    parser.add_argument('-u', '--unpack', action='store_const', const=True, default=False)
    namespace = parser.parse_args(sys.argv[1:])


    if namespace.files:
        # filename = 'Zapolnennoe_po_faktoram.xlsx'
        create_files(namespace.files, namespace.validate)
        exit()

    model = Net()

    if namespace.unpack:
        img = readb64(test_64)
        predict_image(model, img)
        exit()

    if namespace.train:
        train(model, namespace.number, namespace.model)
    else:
        test(model, namespace.model, namespace.validate, namespace.predict)
